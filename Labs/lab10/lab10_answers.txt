CS-220 Spring 2017 Lab 10 answers		Due: April 25, 2017

1. Cut and paste a copy of your successful test.txt file that creates a texthex.txt 
   file that invokes the target function:


# Put input for makeHex in this file.
# Lines that start with "#" are comments and are ignored by makeHex
# Lines that start with "C " are character strings, the data is copied to the output (testHex.txt)
# Lines that start with "X " are hexadecimal strings, the data is converted from hex to ASCII and copied
#    to the output (testHex.txt)
C This is a character string that goes on for a very long distance so that it overflows its bufferssssssss
X 500640
# 0x400650

   
2. Notice that the target function in target.c ends with an "exit(0)" invocation.  The
   "exit(0)" causes the target function to return directly to the operating system cleanup
   routine instead of to the function that called "target".  If the target function had 
   ended with "return false" instead of "exit(0)", would target still run successfully?
   If not, what might happen and why?

   I wouldn’t have been successful because the return address would no longer exist and therefore, if returning false, it would have no function to go to. 
   
3. If target.c had used fgets instead of gets, would your buffer overflow attack have been succesful?
   Why or why not?

	No, because fgets prevents buffer overwrite, therefore preventing the overflow attack.
   
4. Did the Makefile make this lab easier or harder to run?  Is it worth the time to build a correct
   Makefile so that dependencies are automatically taken care of?

	It made the lab easier because it saves a significant amount of time.
   
5. Now that you know how to do a buffer overflow attack, could you do a buffer overflow
   attack on target WITHOUT looking at target.c?  If not, why not?  If so, what tools
   would you use to figure out what is in the "target" executable file?

	I can’t do a buffer overflow attack without looking at the .c file because I found it difficult to locate the buffer and the size of the allotted array in memory. Without finding those, it becomes difficult to overflow the buffer and the return address.